<script type="text/javascript">
  var gk_isXlsx = false;
  var gk_xlsxFileLookup = {};
  var gk_fileData = {};
  function filledCell(cell) {
    return cell !== "" && cell != null;
  }
  function loadFileData(filename) {
    if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
      try {
        var workbook = XLSX.read(gk_fileData[filename], { type: "base64" });
        var firstSheetName = workbook.SheetNames[0];
        var worksheet = workbook.Sheets[firstSheetName];

        // Convert sheet to JSON to filter blank rows
        var jsonData = XLSX.utils.sheet_to_json(worksheet, {
          header: 1,
          blankrows: false,
          defval: "",
        });
        // Filter out blank rows (rows where all cells are empty, null, or undefined)
        var filteredData = jsonData.filter((row) => row.some(filledCell));

        // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
        var headerRowIndex = filteredData.findIndex(
          (row, index) =>
            row.filter(filledCell).length >=
            filteredData[index + 1]?.filter(filledCell).length
        );
        // Fallback
        if (headerRowIndex === -1 || headerRowIndex > 25) {
          headerRowIndex = 0;
        }

        // Convert filtered JSON back to CSV
        var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
        csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
        return csv;
      } catch (e) {
        console.error(e);
        return "";
      }
    }
    return gk_fileData[filename] || "";
  }
</script>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pong</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #000;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      let ball, leftPaddle, rightPaddle;
      let leftScore = 0,
        rightScore = 0;
      let gameState = "menu";
      let scoreLimit = 11;

      function setup() {
        createCanvas(800, 600);
        ball = new Ball();
        leftPaddle = new Paddle(20, height / 2 - 50, true);
        rightPaddle = new Paddle(width - 40, height / 2 - 50, false);
        textAlign(CENTER, CENTER);
        textSize(32);
        fill(255);
      }

      function draw() {
        background(0);
        drawCourt();

        if (gameState === "menu") {
          text("Pong\nPress SPACE to Start", width / 2, height / 2);
          if (keyIsPressed && key === " ") {
            gameState = "playing";
          }
        } else if (gameState === "playing") {
          leftPaddle.update();
          rightPaddle.update();
          ball.update();
          leftPaddle.show();
          rightPaddle.show();
          ball.show();
          displayScores();
          checkWin();
        } else if (gameState === "gameOver") {
          text(
            `${
              leftScore >= scoreLimit ? "Player 1" : "Player 2"
            } Wins!\nPress SPACE to Restart`,
            width / 2,
            height / 2
          );
          if (keyIsPressed && key === " ") {
            leftScore = 0;
            rightScore = 0;
            ball.reset();
            gameState = "playing";
          }
        }
      }

      function drawCourt() {
        stroke(128);
        line(width / 2, 0, width / 2, height);
        stroke(255, 0, 0);
        line(0, 0, 0, height);
        line(width, 0, width, height);
        line(0, 0, width, 0);
        line(0, height, width, height);
      }

      function displayScores() {
        text(leftScore, width / 4, 50);
        text(rightScore, (3 * width) / 4, 50);
      }

      function checkWin() {
        if (leftScore >= scoreLimit || rightScore >= scoreLimit) {
          gameState = "gameOver";
        }
      }

      class Paddle {
        constructor(x, y, isLeft) {
          this.x = x;
          this.y = y;
          this.w = 20;
          this.h = 100;
          this.speed = 5;
          this.isLeft = isLeft;
        }

        update() {
          if (this.isLeft) {
            if (keyIsDown(87)) this.y -= this.speed; // W key
            if (keyIsDown(83)) this.y += this.speed; // S key
          } else {
            if (keyIsDown(UP_ARROW)) this.y -= this.speed;
            if (keyIsDown(DOWN_ARROW)) this.y += this.speed;
          }
          this.y = constrain(this.y, 0, height - this.h);
        }

        show() {
          rect(this.x, this.y, this.w, this.h);
        }
      }

      class Ball {
        constructor() {
          this.reset();
        }

        reset() {
          this.x = width / 2;
          this.y = height / 2;
          this.r = 10;
          this.speed = 5;
          this.angle = random([-PI / 4, PI / 4, (3 * PI) / 4, (-3 * PI) / 4]);
          this.vx = this.speed * cos(this.angle);
          this.vy = this.speed * sin(this.angle);
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;

          // Wall collision
          if (this.y <= this.r || this.y >= height - this.r) {
            this.vy *= -1;
          }

          // Paddle collision
          if (
            this.x - this.r <= leftPaddle.x + leftPaddle.w &&
            this.y >= leftPaddle.y &&
            this.y <= leftPaddle.y + leftPaddle.h
          ) {
            let hitPos = (this.y - leftPaddle.y) / leftPaddle.h;
            this.angle = map(hitPos, 0, 1, -PI / 3, PI / 3);
            this.vx = this.speed * cos(this.angle);
            this.vy = this.speed * sin(this.angle);
          }
          if (
            this.x + this.r >= rightPaddle.x &&
            this.y >= rightPaddle.y &&
            this.y <= rightPaddle.y + rightPaddle.h
          ) {
            let hitPos = (this.y - rightPaddle.y) / rightPaddle.h;
            this.angle = map(hitPos, 0, 1, PI - PI / 3, PI + PI / 3);
            this.vx = this.speed * cos(this.angle);
            this.vy = this.speed * sin(this.angle);
          }

          // Scoring
          if (this.x < 0) {
            rightScore++;
            this.reset();
          } else if (this.x > width) {
            leftScore++;
            this.reset();
          }
        }

        show() {
          // ellipse(this.x, this.y, this.r * 2);
          rect(this.x - this.r, this.y - this.r, this.r, this.r);
        }
      }
    </script>
  </body>
</html>
