<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pong</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #000;
        font-family: Orbitron;
      }
      canvas {
        display: block;
      }
    </style>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron"
      rel="stylesheet"
    />
  </head>
  <body>
    <script>
      let ball, leftPaddle, rightPaddle;
      let leftScore = 0,
        rightScore = 0;
      let gameState = "menu";
      let scoreLimit = 11;

      // All the parts to make a numerical character
      let scoreWidth = 20;
      let scoreHeight = 40;
      let wd = scoreWidth; // width of character in pixels
      let scoreSpace = 5; // number of pixels between characters
      let hd = scoreHeight / 2; // segment height in pixels
      let th = 5; // segment thickness in pixels
      let charBuff = [
        { x: th / 2, y: 0, w: wd, h: th }, // top bar 1
        { x: th / 2, y: hd - th / 2, w: wd, h: th }, // middle bar 2
        { x: th / 2, y: hd + hd - th, w: wd, h: th }, // bottom bar 4
        { x: th / 2, y: 0, w: th, h: hd }, // top left 8
        { x: wd - th / 2, y: 0, w: th, h: hd }, // top right 16
        { x: th / 2, y: hd, w: th, h: hd }, // bot left 32
        { x: wd - th / 2, y: hd, w: th, h: hd }, // bot right 64
      ];

      // add bit values for the parts needed for each number
      let charTranslation = [
        1 + 4 + 8 + 16 + 32 + 64, // 0
        16 + 64, //1
        1 + 16 + 2 + 32 + 4, //2
        1 + 2 + 4 + 16 + 64, //3
        8 + 16 + 64 + 2, //4
        1 + 2 + 4 + 8 + 64, //5
        1 + 2 + 4 + 8 + 32 + 64, //6
        1 + 16 + 64, //7
        1 + 2 + 4 + 8 + 16 + 32 + 64, //8
        1 + 2 + 4 + 8 + 16 + 64, //9
      ];

      let menuText = [
        "Single player",
        "Two player",
        "Clanker battle",
        "Sound Off",
      ];

      let menuSelection = 0;
      let enableSound = true;
      let enableLeftScore = true;

      // x,y pixel location of center
      function drawScore(x, y, value) {
        // get width of value in characters
        let valueStr = value.toString();
        let valueWidth = valueStr.length;
        console.log(`width:${valueWidth}`);

        // set the starting position
        let xp = x - valueWidth * scoreWidth;
        let yp = y - scoreHeight / 2;

        // loop each char in value
        for (let vchar of valueStr) {
          console.log(`vchar ${vchar}`);
          // Get the bitmask for the digit
          let segments = charTranslation[int(vchar)];

          // Draw only the segments that are set in the bitmask
          charBuff.forEach((item, index) => {
            // Check if the bit for this segment is set
            if (segments & (1 << index)) {
              // Draw rectangle with offset x, y
              rect(item.x + xp, item.y + yp, item.w, item.h);
            }
          });
          xp += scoreWidth + scoreSpace;
        }
      }

      function setup() {
        textFont("Orbitron");
        createCanvas(800, 600);
        ball = new Ball();
        leftPaddle = new Paddle(20, height / 2 - 50, true);
        rightPaddle = new Paddle(width - 40, height / 2 - 50, false);
        textAlign(CENTER, CENTER);
        textSize(32);
        fill(255);
      }

      function draw() {
        background(0);
        drawCourt();
        displayScores();

        if (gameState === "menu") {
          menu();
        } else if (gameState === "playing") {
          // two player
          leftPaddle.update();
          rightPaddle.update();
          ball.update();
          leftPaddle.show();
          rightPaddle.show();
          ball.show();
          displayScores();
          checkWin();
        } else if (gameState === "playing1") {
          // one player
          rightPaddle.update();
          ball.update();
          rightPaddle.show();
          ball.show();
          displayScores();
          checkWin();
        } else if (gameState === "playing2") {
          // robot/clanker
          leftPaddle.update();
          rightPaddle.update();
          ball.update();
          leftPaddle.show();
          rightPaddle.show();
          ball.show();
          displayScores();
          checkWin();
        } else if (gameState === "gameOver") {
          displayScores();
          if (enableLeftScore) {
            text(
              `${leftScore >= scoreLimit ? "Player 1" : "Player 2"} Wins!`,
              width / 2,
              height / 2 - 150
            );
          } else {
            text(`Game Over`, width / 2, height / 2 - 150);
          }

          menu();
        }
      }

      function menu() {
        let sp = 40;

        for (let x = 0; x < menuText.length; x++) {
          fill(70);
          if (menuSelection === x) {
            rect(
              width / 2 - 150,
              height / 2 - (menuText.length * sp) / 2 + sp * x - sp / 2,
              300,
              sp
            );
          }
          fill(255);
          text(
            menuText[x],
            width / 2,
            height / 2 - (menuText.length * sp) / 2 + sp * x
          );
        }
      }

      function keyPressed() {
        if (
          gameState === "playing" ||
          gameState === "playing1" ||
          gameState === "playing2"
        )
          return;

        if (keyCode === UP_ARROW && menuSelection > 0) {
          menuSelection--;
        }

        if (keyCode === DOWN_ARROW && menuSelection < menuText.length - 1) {
          menuSelection++;
        }

        if (keyCode === ENTER || key === " ") {
          if (menuSelection === 0) {
            enableLeftScore = false;
            leftScore = 0;
            rightScore = 0;
            ball.reset();
            gameState = "playing1";
            return;
          }

          if (menuSelection === 1) {
            enableLeftScore = true;
            leftScore = 0;
            rightScore = 0;
            ball.reset();
            gameState = "playing";
            return;
          }

          if (menuSelection === 2) {
            enableLeftScore = true;
            leftScore = 0;
            rightScore = 0;
            ball.reset();
            gameState = "playing2";
            return;
          }

          if (menuSelection === 3) {
            if (enableSound) {
              menuText[3] = "Sound Off";
              enableSound = false;
            } else {
              menuText[3] = "Sound On";
              enableSound = true;
            }
            return;
          }
        }
      }

      function drawCourt() {
        strokeCap(SQUARE);
        strokeWeight(10);

        if (gameState === "playing") {
          stroke(255);
        } else {
          stroke(64);
        }

        drawingContext.setLineDash([20, 20]);
        line(width / 2, 10, width / 2, height);
        drawingContext.setLineDash([]);

        stroke(255);
        line(0, 0, width, 0);

        line(0, height, width, height);

        if (gameState === "playing1") {
          line(0, 0, 0, height);
        }

        strokeWeight(1);
      }

      function displayScores() {
        let sp = 5;
        if (enableLeftScore) {
          let offset = width / 4;
          drawScore(offset, 40, int(leftScore));
        }

        offset = (3 * width) / 4;
        drawScore(offset, 40, int(rightScore));
      }

      function checkWin() {
        if (
          (leftScore >= scoreLimit || rightScore >= scoreLimit) &&
          enableLeftScore
        ) {
          gameState = "gameOver";
        }

        if (leftScore >= 1 && !enableLeftScore) {
          gameState = "gameOver";
        }
      }

      class Paddle {
        constructor(x, y, isLeft) {
          this.x = x;
          this.y = y;
          this.w = 20;
          this.h = 100;
          this.speed = 5;
          this.isLeft = isLeft;
        }

        update() {
          if (this.isLeft) {
            if (keyIsDown(87)) this.y -= this.speed; // W key
            if (keyIsDown(83)) this.y += this.speed; // S key
          } else {
            if (keyIsDown(UP_ARROW)) this.y -= this.speed;
            if (keyIsDown(DOWN_ARROW)) this.y += this.speed;
          }
          this.y = constrain(this.y, 0, height - this.h);
        }

        show() {
          rect(this.x, this.y, this.w, this.h);
        }
      }

      class Ball {
        constructor() {
          this.reset();
        }

        reset() {
          this.x = width / 2;
          this.y = height / 2;
          this.r = 10;
          this.speed = 5;
          this.angle = random([-PI / 4, PI / 4, (3 * PI) / 4, (-3 * PI) / 4]);
          this.vx = this.speed * cos(this.angle);
          this.vy = this.speed * sin(this.angle);
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;

          // Wall collision
          if (this.y <= this.r || this.y >= height - this.r) {
            this.vy *= -1;
          }

          // single player wall bounce
          if (gameState === "playing1") {
            if (this.x <= this.r) {
              this.vx *= -1;
            }
          }

          // Paddle collision
          // left
          if (
            enableLeftScore == true &&
            this.x - this.r <= leftPaddle.x + leftPaddle.w &&
            this.y >= leftPaddle.y &&
            this.y <= leftPaddle.y + leftPaddle.h
          ) {
            let hitPos = (this.y - leftPaddle.y) / leftPaddle.h;
            this.angle = map(hitPos, 0, 1, -PI / 3, PI / 3);
            this.vx = this.speed * cos(this.angle);
            this.vy = this.speed * sin(this.angle);
          }

          // right
          if (
            this.x + this.r >= rightPaddle.x &&
            this.y >= rightPaddle.y &&
            this.y <= rightPaddle.y + rightPaddle.h
          ) {
            if (gameState === "playing1") {
              rightScore++;
            }
            let hitPos = (this.y - rightPaddle.y) / rightPaddle.h;
            this.angle = map(hitPos, 0, 1, PI - PI / 3, PI + PI / 3);
            this.vx = this.speed * cos(this.angle);
            this.vy = this.speed * sin(this.angle);
          }

          // Scoring
          if (this.x < 0) {
            rightScore++;
            this.reset();
          } else if (this.x > width) {
            leftScore++;
            this.reset();
          }
        }

        show() {
          rect(this.x - this.r, this.y - this.r, this.r, this.r);
        }
      }
    </script>
  </body>
</html>
