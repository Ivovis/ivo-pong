<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pong</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #000;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      let ball, leftPaddle, rightPaddle;
      let leftScore = 0,
        rightScore = 0;
      let gameState = "menu";
      let scoreLimit = 11;

      // All the parts to make a numerical character
      let scoreWidth = 20;
      let wd = scoreWidth;
      let hd = 20;
      let th = 5;
      let charBuff = [
        { x: th / 2, y: 0, w: wd, h: th }, // top bar 1
        { x: th / 2, y: hd - th / 2, w: wd, h: th }, // middle bar 2
        { x: th / 2, y: hd + hd - th, w: wd, h: th }, // bottom bar 4
        { x: th / 2, y: 0, w: th, h: hd }, // top left 8
        { x: wd - th / 2, y: 0, w: th, h: hd }, // top right 16
        { x: th / 2, y: hd, w: th, h: hd }, // bot left 32
        { x: wd - th / 2, y: hd, w: th, h: hd }, // bot right 64
      ];

      // add bit values for the parts needed for each number
      let charTranslation = [
        1 + 4 + 8 + 16 + 32 + 64, // 0
        16 + 64, //1
        1 + 16 + 2 + 32 + 4, //2
        1 + 2 + 4 + 16 + 64, //3
        8 + 16 + 64 + 2, //4
        1 + 2 + 4 + 8 + 64, //5
        1 + 2 + 4 + 8 + 32 + 64, //6
        1 + 16 + 64, //7
        1 + 2 + 4 + 8 + 16 + 32 + 64, //8
        1 + 2 + 4 + 8 + 16 + 64, //9
      ];

      // x,y pixel location of top left of the digit
      function drawScore(x, y, value) {
        // Get the bitmask for the digit
        let segments = charTranslation[value];

        // Draw only the segments that are set in the bitmask
        charBuff.forEach((item, index) => {
          // Check if the bit for this segment is set
          if (segments & (1 << index)) {
            // Draw rectangle with offset x, y
            rect(item.x + x, item.y + y, item.w, item.h);
          }
        });
      }

      function setup() {
        createCanvas(800, 600);
        ball = new Ball();
        leftPaddle = new Paddle(20, height / 2 - 50, true);
        rightPaddle = new Paddle(width - 40, height / 2 - 50, false);
        textAlign(CENTER, CENTER);
        textSize(32);
        fill(255);
      }

      function draw() {
        background(0);
        drawCourt();

        if (gameState === "menu") {
          text("Pong\nPress SPACE to Start", width / 2, height / 2);
          if (keyIsPressed && key === " ") {
            gameState = "playing";
          }
        } else if (gameState === "playing") {
          leftPaddle.update();
          rightPaddle.update();
          ball.update();
          leftPaddle.show();
          rightPaddle.show();
          ball.show();
          displayScores();
          checkWin();
        } else if (gameState === "gameOver") {
          displayScores();
          text(
            `${
              leftScore >= scoreLimit ? "Player 1" : "Player 2"
            } Wins!\nPress SPACE to Restart`,
            width / 2,
            height / 2
          );
          if (keyIsPressed && key === " ") {
            leftScore = 0;
            rightScore = 0;
            ball.reset();
            gameState = "playing";
          }
        }
      }

      function drawCourt() {
        strokeCap(SQUARE);
        strokeWeight(10);

        if (gameState === "playing") {
          stroke(255);
        } else {
          stroke(64);
        }

        drawingContext.setLineDash([20, 20]);
        line(width / 2, 10, width / 2, height);
        drawingContext.setLineDash([]);

        stroke(255);
        line(0, 0, width, 0);
        line(0, height, width, height);
        strokeWeight(1);
      }

      function displayScores() {
        let sp = 5;
        let offset = width / 4;
        if (leftScore > 9) {
          drawScore(offset - scoreWidth / 2 - sp, 20, int(leftScore / 10));
          drawScore(offset + scoreWidth / 2 + sp, 20, int(leftScore - 10));
        } else {
          drawScore(offset - scoreWidth / 2, 20, int(leftScore));
        }

        offset = (3 * width) / 4;
        if (rightScore > 9) {
          drawScore(offset - scoreWidth / 2 - sp, 20, int(rightScore / 10));
          drawScore(offset + scoreWidth / 2 + sp, 20, int(rightScore - 10));
        } else {
          drawScore(offset - scoreWidth / 2, 20, int(rightScore));
        }
      }

      function checkWin() {
        if (leftScore >= scoreLimit || rightScore >= scoreLimit) {
          gameState = "gameOver";
        }
      }

      class Paddle {
        constructor(x, y, isLeft) {
          this.x = x;
          this.y = y;
          this.w = 20;
          this.h = 100;
          this.speed = 5;
          this.isLeft = isLeft;
        }

        update() {
          if (this.isLeft) {
            if (keyIsDown(87)) this.y -= this.speed; // W key
            if (keyIsDown(83)) this.y += this.speed; // S key
          } else {
            if (keyIsDown(UP_ARROW)) this.y -= this.speed;
            if (keyIsDown(DOWN_ARROW)) this.y += this.speed;
          }
          this.y = constrain(this.y, 0, height - this.h);
        }

        show() {
          rect(this.x, this.y, this.w, this.h);
        }
      }

      class Ball {
        constructor() {
          this.reset();
        }

        reset() {
          this.x = width / 2;
          this.y = height / 2;
          this.r = 10;
          this.speed = 5;
          this.angle = random([-PI / 4, PI / 4, (3 * PI) / 4, (-3 * PI) / 4]);
          this.vx = this.speed * cos(this.angle);
          this.vy = this.speed * sin(this.angle);
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;

          // Wall collision
          if (this.y <= this.r || this.y >= height - this.r) {
            this.vy *= -1;
          }

          // Paddle collision
          if (
            this.x - this.r <= leftPaddle.x + leftPaddle.w &&
            this.y >= leftPaddle.y &&
            this.y <= leftPaddle.y + leftPaddle.h
          ) {
            let hitPos = (this.y - leftPaddle.y) / leftPaddle.h;
            this.angle = map(hitPos, 0, 1, -PI / 3, PI / 3);
            this.vx = this.speed * cos(this.angle);
            this.vy = this.speed * sin(this.angle);
          }
          if (
            this.x + this.r >= rightPaddle.x &&
            this.y >= rightPaddle.y &&
            this.y <= rightPaddle.y + rightPaddle.h
          ) {
            let hitPos = (this.y - rightPaddle.y) / rightPaddle.h;
            this.angle = map(hitPos, 0, 1, PI - PI / 3, PI + PI / 3);
            this.vx = this.speed * cos(this.angle);
            this.vy = this.speed * sin(this.angle);
          }

          // Scoring
          if (this.x < 0) {
            rightScore++;
            this.reset();
          } else if (this.x > width) {
            leftScore++;
            this.reset();
          }
        }

        show() {
          // ellipse(this.x, this.y, this.r * 2);
          rect(this.x - this.r, this.y - this.r, this.r, this.r);
        }
      }
    </script>
  </body>
</html>
